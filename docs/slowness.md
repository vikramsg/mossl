# HTTPS GET Slowness Notes

This document captures why `make test-https`/`tests/test_https_get.mojo` can feel slow even when all sites pass.

## Benchmarks (Jan 5, 2026)

We benchmarked core crypto operations to identify bottlenecks. The following output was generated by running `bash bench/run.sh`.

```text
---------------------------------------------------
Running Mojo Benchmarks...
RSA-2048 Verify (Mojo): 1759.82 ops/sec
ECDSA P-384 Verify (Mojo): 1.16 ops/sec
BigInt ModPow (2048-bit) (Mojo): 1830.15 ops/sec
---------------------------------------------------
Running Python Benchmarks (Reference)...
RSA-2048 Verify (Python): 64695.07 ops/sec
ECDSA P-384 Verify (Python): 4657.50 ops/sec
BigInt ModPow (2048-bit) (Python): 3316.29 ops/sec
---------------------------------------------------
```

## Conclusions (Initial)

- **Critical Bottleneck: ECDSA P-384**: Verifying a single ECDSA P-384 signature in Mojo takes ~0.86 seconds (~1.16 ops/sec). Compared to Python's optimized native implementation (4657 ops/sec), Mojo is **~4000x slower**. This is definitively the primary cause of slowness.
- **RSA Performance**: Mojo's RSA is significantly slower than native (~1,760 vs ~64,700 ops/sec), but ~1.7k ops/sec is acceptable for typical test loads and not the blocking factor.
- **BigInt Performance**: Mojo's BigInt modular exponentiation is roughly 2x slower than Python (1830 vs 3316 ops/sec), which is reasonable given it's a pure software implementation.

## Investigation Update (Jan 5, 2026 - Part 2)

After optimizing ECDSA P-384 to ~800 ops/sec, `make test-https` remained slow (~44s total, ~12s CPU for 10 requests). Further profiling (`bench/bench_profiling.mojo`) revealed two remaining critical bottlenecks:

1.  **ECDSA P-256 is Unoptimized (~1.5 ops/sec)**:
    *   Most real-world sites (Google, Cloudflare, etc.) use P-256, not P-384.
    *   The P-256 implementation (`src/pki/ecdsa_p256.mojo`) still uses the legacy unoptimized arithmetic (dynamic lists, no windowing), resulting in ~0.65s per verification.
    *   This accounts for the majority of the CPU time (10 requests * ~0.7s = ~7s).

2.  **AES-GCM is Extremely Slow (~0.8 MB/sec)**:
    *   The current AES-GCM implementation (`src/crypto/aes_gcm.mojo`) allocates `List` objects for every intermediate 16-byte block and S-Box lookup.
    *   Throughput is < 1 MB/sec, causing noticeable latency even for small certificate chains and bodies.
    *   **Optimization Proof**: A prototype in `bench/optimize_aes_gcm.mojo` using `UnsafePointer` and allocation-free logic achieved **~45 MB/sec** (a ~32x speedup) on the same hardware.

**Corrected Conclusion:**
The primary cause of slowness is **ECDSA P-256** (used by most sites) and **AES-GCM** (used for all traffic). Optimizing P-384 was necessary but insufficient.

## Future Optimization Work

1.  **Optimize ECDSA P-256**: Port the optimized P-384 logic (stack allocation, unrolled Montgomery multiplication, windowed scalar mul) to P-256.
2.  **Optimize AES-GCM**: Rewrite `src/crypto/aes_gcm.mojo` to avoid `List` allocations in the hot path, using `UnsafePointer` or `InlineArray` and precomputed tables.
3.  **Connection Reuse**: Implementing Keep-Alive in the HTTPS client would reduce the frequency of full TLS handshakes.